{"name":"Eddy","tagline":"Event Driven JS","body":"Event Driven JS\r\n===============\r\n\r\na not so obtrusive and *highly optimized* attempt to make JavaScript more awesome than ever!\r\n\r\n[![build status](https://secure.travis-ci.org/WebReflection/eddy.png)](http://travis-ci.org/WebReflection/eddy)\r\n\r\n[![NPM](https://nodei.co/npm/eddy.png?downloads=true)](https://nodei.co/npm/eddy/)\r\n\r\n### The eddy.js Philosophy\r\nIt does not matter if you code client or server side, we all need the same thing and we keep using this or that library to obtain the same behavior.\r\n\r\nI am talking about all *de-facto standards API* such `.on(type, handler)`, `.once(type, handler)`, `.off(type, handler)` together with `.emit(type, arg1, argN)` and `.listeners(type)` or `.trigger(type, data)` to deal with DOM nodes.\r\n\r\n`eddy.js` aim is to harmonize all these API at core level polluting in a **non enumerable** way the `Object.prototype` in a smart way that simply works!\r\n\r\nThis means, *as soon as we use one of those methods, objects become lazily Event Targets* so we can use them as such.\r\n\r\nAs summary, [this is the philosophy behind this module](https://twitter.com/WebReflection/status/354958592601899008)\r\n\r\n> eddy.js is a very pragmatic approach, back those days where developers enriched native prototypes to do more with less code ;-)\r\n\r\n\r\n### Compatibility\r\n\r\n`eddy.js` is compatible with the following **mobile platforms**\r\n\r\n  * iOS 5, 6, 7+\r\n  * Android 2.2+, 3, 4.0, 4.1, 4.2, 4.3+\r\n  * Windows Phone 7, 8+\r\n  * FirefoxOS 0.X, 1+\r\n  * Blackberry 10 (probably older too, haven't tested yet)\r\n  * Opera Mini, Opera Mobile, and Opera Mobile Beta\r\n  * webOS 2+\r\n  * Nokia Asha and Nokia Xpress browser\r\n\r\neddy is also compatible with the following **desktop browsers**\r\n\r\n  * Chrome, Canary, and Chromium channel\r\n  * Safari 5+ and Webkit Nightly\r\n  * Internet Explorer 8, 9, 10, 11+\r\n  * Firefox, Aurora, and Nightly channel\r\n  * Opera\r\n\r\nIn order to verify your browser too please [visit the test page](http://webreflection.github.io/eddy/test/).\r\n\r\n\r\n### Object.prototype Enriched API\r\nHere a list of methods you can use by default in an `eddy.js` environment.\r\n\r\n\r\n#### Object#on(type, handler[, capture])\r\nReturns the object itself after adding an event handler.\r\nThis is basically the equivalent of `addListener` or `addEventListener`, where duplicated handlers for the same event are not allowed.\r\n```javascript\r\nvar stopWatch = {\r\n  startTime: Date.now()\r\n}.on(\r\n  'change',\r\n  function () {\r\n    // log elapsed time per each change\r\n    console.log(Date.now() - this.startTime);\r\n  }\r\n);\r\n\r\nsetInterval(function () {\r\n  stopWatch.emit('change');\r\n}, 10);\r\n\r\n// or using the boundTo method\r\n// and the extra arguments accepted by setInterval\r\nsetInterval(stopWatch.boundTo('emit'), 10, 'change');\r\n```\r\nThe `handler` can be either a function or an object as it is for `DOM` methods such `addEventListener` or `removeEventListener`.\r\nIn this case the method `handleEvent` is invoked with the object itself as context as it is for the [native DOM behavior](http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventListener).\r\n\r\nThe third boolean `capture` argument is useless with JS objects but might be used in some `DOM` specific case.\r\nBy default, `capture` is false.\r\n\r\n\r\n#### Object#once(type, handler[, capture])\r\nSame as `Object#on(type, handler[, capture])` except the event is triggered once and never again unless specified later on.\r\n```javascript\r\n// on a generic HTML page inside a script tag...\r\nthis.once('load', function(e) {\r\n  console.log('page fully loaded');\r\n  // even if triggered manually\r\n  // this event won't fire anymore\r\n  this.fire('load');\r\n  // nothing happened\r\n});\r\n```\r\n\r\n\r\n#### Object#off(type, handler[, capture])\r\nReturns the object itself after removing an event handler, if present.\r\nThis is basically the equivalent of `removeListener` or `removeEventListener`.\r\n```javascript\r\nfunction clearAllEntries() {\r\n  database.clear();\r\n}\r\nwindow.on('unload', clearAllEntries);\r\nkeepEntriesButton.on('click', function () {\r\n  // drop the clear procedure\r\n  window.off('unload', clearAllEntries);\r\n});\r\n```\r\n\r\n\r\n#### Object#trigger(type[, data])\r\nTriggers / fires all handlers associated to the event `type` enriching the event with arbitrary `data`.\r\nIf specified, `data` must be an object with one or more properties.\r\n`data` will be attached as event property too while properties will be copied over the event object.\r\n\r\nThis method is more suitable for DOM events or those events based on a single argument parameter/object.\r\n```javascript\r\nwindow.onresize = function (e) {\r\n  alert(e.manual);\r\n};\r\nwindow.trigger('resize', {manual:true});\r\n```\r\n\r\n\r\n#### Object#emit(type[, arg1][, argN])\r\nThis method [behaves like node.js](http://nodejs.org/api/events.html#events_emitter_emit_event_arg1_arg2) one, accepting one or more optional arguments after the type.\r\n```javascript\r\nvar object = {}\r\n  .on('modify', function (key, value) {\r\n    this[key] = value;\r\n  })\r\n  .on('delete', function (key) {\r\n    delete this[key];\r\n  })\r\n;\r\nobject.emit('modify', 'key', Math.random());\r\nconsole.log(object.key); // 0.3245979759376496\r\nobject.emit('delete', 'key');\r\nconsole.log(object.key); // undefined\r\n```\r\n\r\n\r\n#### Object#listeners(type)\r\nThis method [behaves like node.js](http://nodejs.org/api/events.html#events_emitter_listeners_event) one but on DOM object it will always return an empty array-like object.\r\n\r\n```javascript\r\nfunction handler() {}\r\nvar obj = {}.on('event', handler);\r\nvar listeners = obj.listeners('event');\r\n\r\nconsole.log(listeners[0] === handler); // true\r\n```\r\nIn the DOM world there's no way to retrieve back nodes and it has never been a real problem but for _node.js_ or generic _JS business logic_ the possibility to understand already added listeners might be handy (I needed this in [dblite](https://github.com/WebReflection/dblite#dblite) and I've realized it is a very handy method!)\r\n\r\n\r\n#### Object#boundTo(method)\r\nThis method creates a single bound version of the generic function or instance method.\r\n```javascript\r\nvar obj = {\r\n  test: function () {\r\n    console.log(this === obj);\r\n  }\r\n};\r\nconsole.log(\r\n  obj.boundTo('test') === obj.boundTo('test')\r\n); // true\r\nobj.boundTo('test')(); // true\r\n```\r\nIf the argument is *a function instead of a string* that function is used instead.\r\n```javascript\r\nfunction test() {\r\n  console.log(this === obj);\r\n}\r\nvar obj = {};\r\nconsole.log(\r\n  obj.boundTo(test) === obj.boundTo(test)\r\n); // true\r\nobj.boundTo(test)(); // true\r\n```\r\nSame thing if we pass the method itself as function instead of method name:\r\n```javascript\r\nvar obj = {\r\n  test: function () {\r\n    console.log(this === obj);\r\n  }\r\n};\r\nconsole.log(\r\n  obj.boundTo(obj.test) === obj.boundTo('test')\r\n); // true\r\n```\r\n\r\n\r\n### Array.prototype Enriched API\r\nNew in version `0.3`, all `Array.prototype` methods but `boundTo` and `listeners` have been made smart enough to perform the same call inside each item of the array.\r\n\r\nThis approach simplifies a very common pattern with collections, specially in the DOM world, so that we can add or remove events to many objects at once.\r\n\r\n```javascript\r\nfunction query(CSS, parentNode) {\r\n  return Array.prototype.slice.call(\r\n    (parentNode || document).querySelectorAll(CSS)\r\n  );\r\n}\r\n\r\n// later on ...\r\nquery('ul > li').on('click', doStuff);\r\n```\r\nThe assumption is that collections are commonly used like that.\r\n\r\n\r\n### Which File ?\r\n`eddy.js` comes in different flavors but it operates on global, native, constructors.\r\nThis means once you require or include or load `eddy.js` you need to manually `delete` polluted prototypes if needed.\r\nAnyway, here the list of files you need:\r\n\r\n * [browser without DOM](build/eddy.js), for *browsers* meaning down to IE6 baby, fear not!\r\n * [browser with DOM](build/eddy.dom.js), for *browsers* meaning IE8, using [ie8 file](https://github.com/WebReflection/ie8#ie8) plus all modern mobile and desktop browsers\r\n * [AMD including DOM](build/eddy.amd.js), same as `eddy.dom.js` inside the require AMD logic\r\n * [node.js](build/eddy.node.js), meaning node.js and other server side engines since no export is used/needed\r\n\r\nYou can install `eddy.js` directly via `npm install eddy` too and simply use `require('eddy')`.\r\nThe version for node should work for Rhino too without problems ;-)\r\n\r\n\r\n### Why Eddy As Name ?\r\nNot only because of the \" *Event Driven* sound check \", the definition I prefer is the following one:\r\n\r\n> a current or trend, as of opinion or events, running counter to the main current.\r\n\r\nbut [all other definitions](http://dictionary.reference.com/browse/eddy) are somehow very metaphoric too ;-)\r\n\r\n\r\n### Not Your Meal ?\r\nIf you are stuck in late 90s dogmas about JS and forbidden `Object.prototype` pollution, you can always go for [EventTarget](https://github.com/WebReflection/event-target#event-target) mixin and use that with all your classes.\r\n\r\nWhat `eddy.js` gives you here, is the ability to forget all these problems and use emitters when you need them, if you need them, as easy as that.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}