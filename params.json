{"name":"Eddy","tagline":"Event Driven JS","body":"Event Driven JS\r\n===============\r\n\r\na not so obtrusive and *highly optimized* attempt to make JavaScript more awesome than ever!\r\n\r\n[![build status](https://secure.travis-ci.org/WebReflection/eddy.png)](http://travis-ci.org/WebReflection/eddy)\r\n\r\n[![NPM](https://nodei.co/npm/eddy.png?downloads=true)](https://nodei.co/npm/eddy/)\r\n\r\n\r\n#### Now in cdnJS\r\nMany thanks to [cdnjs](http://www.cdnjs.com) for hosting this script. Following an example on how to include it.\r\n```html\r\n<script\r\n  src=\"//cdnjs.cloudflare.com/ajax/libs/eddy/0.6.3/eddy.dom.js\"\r\n>/* eddy.js */</script>\r\n```\r\n\r\nIn order to have a fully patched environment for older browser too, we could include these scripts too:\r\n```html\r\n<!--[if IE 8]><script\r\n  src=\"//cdnjs.cloudflare.com/ajax/libs/ie8/0.2.3/ie8.js\"\r\n></script><![endif]-->\r\n<script\r\n  src=\"//cdnjs.cloudflare.com/ajax/libs/dom4/1.0.1/dom4.js\"\r\n>/* DOM4 */</script>\r\n<script\r\n  src=\"//cdnjs.cloudflare.com/ajax/libs/eddy/0.6.3/eddy.dom.js\"\r\n>/* eddy.js */</script>\r\n```\r\n\r\n\r\n### The eddy.js Philosophy\r\nIt does not matter if you code client or server side, we all need the same thing and we keep using this or that library to obtain the same behavior.\r\n\r\nI am talking about all *de-facto standards API* such `.on(type, handler)`, `.once(type, handler)`, `.off(type, handler)` together with `.emit(type, arg1, argN)` and `.listeners(type)` or `.trigger(type, detail)` to deal with DOM nodes.\r\n\r\n`eddy.js` aim is to harmonize all these API at core level polluting in a **non enumerable** way the `Object.prototype` in a smart way that simply works!\r\n\r\nThis means no worries at all for any `for/in` loop you might have in there, even in IE.\r\n\r\nAs summary, [this is the philosophy behind this module](https://twitter.com/WebReflection/status/354958592601899008)\r\n\r\n> eddy.js is a very pragmatic approach, back those days where developers enriched native prototypes to do more with less code ;-)\r\n\r\n\r\n### Compatibility\r\n\r\n`eddy.js` is tested and compatible with the following **mobile platforms**\r\n\r\n  * iOS 5, 6, 7+\r\n  * Android 2.2+, 3, 4.0, 4.1, 4.2, 4.3+\r\n  * Windows Phone 7, 8+\r\n  * FirefoxOS 0.X, 1+\r\n  * Blackberry 10 (probably older too, haven't tested yet)\r\n  * Opera Mini, Opera Mobile, and Opera Mobile Beta\r\n  * webOS 2+\r\n  * Nokia Asha and Nokia Xpress browser\r\n  * UC Browser for Android 2.X or higher\r\n\r\neddy is also compatible with the following **desktop browsers**\r\n\r\n  * Chrome, Canary, and Chromium channel\r\n  * Safari 5+ and Webkit Nightly\r\n  * Internet Explorer 8, 9, 10, 11+\r\n  * Firefox, Aurora, and Nightly channel\r\n  * Opera\r\n\r\nIn order to verify your browser too please [visit the test page](http://webreflection.github.io/eddy/test/).\r\n\r\nLast, but not least, `eddy.js` has been used and tested in the following **server side** platforms\r\n\r\n  * node.js\r\n  * rhino\r\n\r\nIf you clone the repo, just `make test` for node or be sure you have a stable rhino jar and `java -jar /path/to/that/jar/js.jar testrhino.js`.\r\n\r\n\r\n### Object.prototype Enriched API\r\nHere a list of methods you can use by default in an `eddy.js` environment.\r\n\r\n\r\n#### Object#on(type, handler[, capture])\r\nReturns the object itself after adding an event handler.\r\nThis is basically the equivalent of `addListener` or `addEventListener`, where duplicated handlers for the same event are not allowed.\r\n```javascript\r\nvar stopWatch = {\r\n  startTime: Date.now()\r\n}.on(\r\n  'change',\r\n  function () {\r\n    // log elapsed time per each change\r\n    console.log(Date.now() - this.startTime);\r\n  }\r\n);\r\n\r\nsetInterval(function () {\r\n  stopWatch.emit('change');\r\n}, 10);\r\n\r\n// or using the boundTo method\r\n// and the extra arguments accepted by setInterval\r\nsetInterval(stopWatch.boundTo('emit'), 10, 'change');\r\n```\r\nThe `handler` can be either a function or an object as it is for `DOM` methods such `addEventListener` or `removeEventListener`.\r\nIn this case the method `handleEvent` is invoked with the object itself as context as it is for the [native DOM behavior](http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventListener).\r\n\r\nThe third boolean `capture` argument is useless with JS objects but might be used in some `DOM` specific case.\r\nBy default, `capture` is false.\r\n\r\n\r\n#### Object#once(type, handler[, capture])\r\nSame as `Object#on(type, handler[, capture])` except the event is triggered once and never again unless specified later on.\r\n```javascript\r\n// on a generic HTML page inside a script tag...\r\nthis.once('load', function(e) {\r\n  console.log('page fully loaded');\r\n  // even if triggered manually\r\n  // this event won't fire anymore\r\n  this.fire('load');\r\n  // nothing happened\r\n});\r\n```\r\n\r\n\r\n#### Object#off(type, handler[, capture])\r\nReturns the object itself after removing an event handler, if present.\r\nThis is basically the equivalent of `removeListener` or `removeEventListener`.\r\n```javascript\r\nfunction clearAllEntries() {\r\n  database.clear();\r\n}\r\nwindow.on('unload', clearAllEntries);\r\nkeepEntriesButton.on('click', function () {\r\n  // drop the clear procedure\r\n  window.off('unload', clearAllEntries);\r\n});\r\n```\r\n\r\n\r\n#### Object#trigger(type[, detail])\r\nTriggers / fires all handlers associated to the event `type` enriching the event with arbitrary `detail` simulating what `CustomEvent` does in DOM Level 4 specifications.\r\n\r\nThis method is more suitable for DOM events or those events based on a single argument parameter/object.\r\n```javascript\r\nwindow.onresize = function (e) {\r\n  alert(e.detail); // object {any:'detail'}\r\n};\r\nwindow.trigger('resize', {any:'detail'});\r\n```\r\nIn the DOM world, it is possible to use directly `.trigger(new CustomEvent(type, {cancelable:true, bubbles: true, detail: anyData}))`.\r\n\r\nThis method will return `false` if any listener called `event.preventDefault()` since by default all triggered events will be cancelable.\r\n\r\n\r\n#### Object#emit(type[, arg1][, argN])\r\nThis method [behaves like node.js](http://nodejs.org/api/events.html#events_emitter_emit_event_arg1_arg2) one, accepting one or more optional arguments after the type.\r\n```javascript\r\nvar object = {}\r\n  .on('modify', function (key, value) {\r\n    this[key] = value;\r\n  })\r\n  .on('delete', function (key) {\r\n    delete this[key];\r\n  })\r\n;\r\nobject.emit('modify', 'key', Math.random());\r\nconsole.log(object.key); // 0.3245979759376496\r\nobject.emit('delete', 'key');\r\nconsole.log(object.key); // undefined\r\n```\r\n\r\nIn the DOM world this method will dispatch an event with specified type and an `arguments` property for interoperability purpose. Such property will contain optional extra arguments used to `.emit(type, a1, aN)` in first place.\r\n\r\n\r\n#### Object#listeners(type)\r\nThis method [behaves like node.js](http://nodejs.org/api/events.html#events_emitter_listeners_event) one but on DOM object it will always return an empty array-like object.\r\n\r\n```javascript\r\nfunction handler() {}\r\nvar obj = {}.on('event', handler);\r\nvar listeners = obj.listeners('event');\r\n\r\nconsole.log(listeners[0] === handler); // true\r\n```\r\nIn the DOM world there's no way to retrieve back nodes and it has never been a real problem but for _node.js_ or generic _JS business logic_ the possibility to understand already added listeners might be handy (I needed this in [dblite](https://github.com/WebReflection/dblite#dblite) and I've realized it is a very handy method!)\r\n\r\n\r\n#### Object#boundTo(method)\r\nThis method creates a single bound version of the generic function or instance method.\r\n```javascript\r\nvar obj = {\r\n  test: function () {\r\n    console.log(this === obj);\r\n  }\r\n};\r\nconsole.log(\r\n  obj.boundTo('test') === obj.boundTo('test')\r\n); // true\r\nobj.boundTo('test')(); // true\r\n```\r\nIf the argument is *a function instead of a string* that function is used instead.\r\n```javascript\r\nfunction test() {\r\n  console.log(this === obj);\r\n}\r\nvar obj = {};\r\nconsole.log(\r\n  obj.boundTo(test) === obj.boundTo(test)\r\n); // true\r\nobj.boundTo(test)(); // true\r\n```\r\nSame thing if we pass the method itself as function instead of method name:\r\n```javascript\r\nvar obj = {\r\n  test: function () {\r\n    console.log(this === obj);\r\n  }\r\n};\r\nconsole.log(\r\n  obj.boundTo(obj.test) === obj.boundTo('test')\r\n); // true\r\n```\r\n\r\n\r\n#### since version 0.5.2\r\nThe `boundTo` method now is able to set, if not already present, a method to a generic object.\r\n```javascript\r\nvar fn = function(){return this};\r\nobj.boundTo('test', fn) === obj.boundTo('test', function(){})\r\nobj.boundTo('test', fn)() === obj\r\nobj.test === fn\r\n```\r\nThis can be very useful for runtime, in scope, function addressing as example for DOM handlers.\r\n\r\n\r\n#### Object#expect(type1, ..., typeN)\r\nPrepares upfront the generic object to accept later on `when` calls so that it's not needed to `when` with empty listeners anymore but just declare through this method what might be emitted/dispatched/triggered later on.\r\n\r\n```js\r\nvar myApp = new MyApp().expect(\r\n  'geolocation',\r\n  'filePermission',\r\n  'fullScreen'\r\n);\r\n\r\nnavigator.geolocation.getCurrentPosition(\r\n  function(info) {\r\n    myApp.emit('geolocation', info);\r\n  }\r\n);\r\n\r\n// ... later on ...\r\nmyApp\r\n  .when('geolocation', function (info) {\r\n    // map it\r\n  })\r\n  .when('filePermission', function (file) {\r\n    // upload it\r\n  })\r\n  .when('fullScreen', function (err, ok) {\r\n    if (ok) ;// show it!\r\n  })\r\n;\r\n````\r\n\r\n\r\n#### Object#when(type, handler)\r\nThis method simply provides a way to retrieve some data the very first time it has been triggered.\r\n\r\nPlease note this is not an equivalent to [Promises/A+](http://promises-aplus.github.io/promises-spec/), the one implemented in next version of JavaScript, neither [when](https://github.com/cujojs/when#whenjs) library, this is just meant to simplify few common cases in an Event_ish_ way.\r\n```javascript\r\n// async, who knows if and when it will happen\r\n// will be asked only once in any case (not a watchPosition)\r\nnavigator.geolocation.getCurrentPosition(\r\n  function(info) {\r\n    myApp.emit('geocurrentposition', null, info);\r\n  },\r\n  function(err) {\r\n    myApp.emit('geocurrentposition', err || 'unknown', null);\r\n  }\r\n);\r\n\r\n\r\n// wait to retrieve initial position\r\nmyApp.when('geocurrentposition', function(err, pos) {\r\n  if (err) {\r\n    console.error('' + err);\r\n  } else {\r\n    console.log(pos.coords);\r\n  }\r\n});\r\n\r\n// any other object could listen even if resolved\r\n// it wan't ask again for the position\r\n```\r\nAbove example could be extended to database access request or any other classic user operation that should not be asked more than once, decoupling different requests independently.\r\n\r\n#### document.when(\"ready\", callback)\r\nThis is a very special case featured directly in core.\r\nInspired by the most famous `$(document).ready(callback)` behavior, `document.when(\"ready\", callback)` acts exactly the same way.\r\n\r\nIf you load `eddy.dom.js` lazily, this should work in any case even after the `DOMContentLoaded` and for all supported browsers.\r\n\r\n```javascript\r\n// even if lazily loaded\r\ndocument.when('ready', function(e){\r\n  console.log('we are ready to go');\r\n});\r\n\r\n// later, even loaded asynchronously and without AMD\r\ndocument.when('ready', initLibrary);\r\n```\r\n\r\nThis will ensure that the event will be available whenever a script will ask to listen for the `ready` event.\r\n\r\nPlease note that if the document is already ready, this will be fired asynchronously and ASAP but never inline.\r\n\r\n\r\n### DOM Only\r\nIn order to make life easier on DOM world too, there are few extra methods on top of regular `eddy` stuff, including same behavior for `XMLHttpRequest`.\r\n\r\n#### DOM#data(key[, value])\r\nThis method is a normalizer for the `dataset` magic attributes behavior with one exception: you can simply assign `null` or `undefined` to remove the attribute when and if not needed anymore.\r\n```javascript\r\nvar div = document.createElement('div');\r\ndiv.data('key', 'value');\r\ndiv.hasAttribute('data-key'); // true\r\ndiv.data('key'); // 'value'\r\ndiv.data('key', null);\r\ndiv.hasAttribute('data-key'); // false\r\n```\r\n\r\n\r\n### Array.prototype Enriched API\r\nNew in version `0.3`, all `Array.prototype` methods but `boundTo` and `listeners` have been made smart enough to perform the same call inside each item of the array.\r\n\r\nThis approach simplifies a very common pattern with collections, specially in the DOM world, so that we can add or remove events to many objects at once.\r\n\r\n```javascript\r\nfunction $(CSS, parentNode) {\r\n  // @link http://webreflection.blogspot.com/2014/05/134-bytes-for-optimized-and-very-basic.html\r\n  var el = parentNode || document,\r\n      first = CSS.lastIndexOf(':first') === CSS.length - 6,\r\n      query = first ?\r\n        el.querySelector(CSS.slice(0, -6)) :\r\n        el.querySelectorAll(CSS);\r\n  return first ?\r\n    (query ? [query] : []) :\r\n    Array.prototype.slice.call(query);\r\n}\r\n\r\n// later on ...\r\n$('ul > li').on('click', doStuff);\r\n```\r\nThe assumption is that collections are commonly used like that.\r\n\r\n\r\n### Which File ?\r\n`eddy.js` comes in different flavors but it operates on global, native, constructors.\r\nThis means once you require or include or load `eddy.js` you need to manually `delete` polluted prototypes if needed.\r\nAnyway, here the list of files you need:\r\n\r\n * [browser without DOM](build/eddy.js), for *browsers* meaning down to IE6 baby, fear not!\r\n * [browser with DOM](build/eddy.dom.js), for *browsers* meaning IE8, using [ie8 file](https://github.com/WebReflection/ie8#ie8) plus all modern mobile and desktop browsers. In order to have an almost fully standard and updated DOM environment, please add [dom4](https://github.com/WebReflection/dom4#dom4) after `ie8` as done as example in the [test page](http://webreflection.github.io/eddy/test/).\r\n * [AMD including DOM](build/eddy.amd.js), same as `eddy.dom.js` inside the require AMD logic. Both `ie8` and `dom4` are strongly suggested here too.\r\n * [node.js](build/eddy.node.js), meaning node.js and other server side engines since no export is used/needed\r\n\r\nYou can install `eddy.js` directly via `npm install eddy` too and simply use `require('eddy')`.\r\nThe version for node should work for Rhino too without problems ;-)\r\n\r\n\r\n### Why Eddy As Name ?\r\nNot only because of the \" *Event Driven* sound check \", the definition I prefer is the following one:\r\n\r\n> a current or trend, as of opinion or events, running counter to the main current.\r\n\r\nbut [all other definitions](http://dictionary.reference.com/browse/eddy) are somehow very metaphoric too ;-)\r\n\r\n\r\n### Not Your Meal ?\r\nIf you are stuck in late 90s dogmas about JS and forbidden `Object.prototype` pollution, you can always go for [EventTarget](https://github.com/WebReflection/event-target#event-target) mixin and use that with all your classes.\r\n\r\nWhat `eddy.js` gives you here, is the ability to forget all these problems and use emitters when you need them, if you need them, as easy as that.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}